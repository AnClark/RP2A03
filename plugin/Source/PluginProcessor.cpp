/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"

//==============================================================================
RP2A03AudioProcessor::RP2A03AudioProcessor()
{
    addPluginParameter (new slParameter (PARAM_ENABLE,       "Enable",       "",     0.0f,      1.0f, 1.0f,    1.0f, 1.0f));
}

RP2A03AudioProcessor::~RP2A03AudioProcessor()
{
}

//==============================================================================
void RP2A03AudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    enableVal.reset (sampleRate, 0.05);
    
    apu.sample_rate (sampleRate);
    
    apu.write_register (0x4015, 0x01);
}

void RP2A03AudioProcessor::releaseResources()
{
}

void RP2A03AudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midi)
{
    enableVal.setValue (getParameter (PARAM_ENABLE)->getUserValue());
    
    int pos = 0;
    MidiMessage msg;
    MidiBuffer::Iterator itr (midi);
    while (itr.getNextEvent (msg, pos))
    {
        if (msg.isNoteOn())
        {
            noteQueue.add (msg.getNoteNumber());
            velocity = msg.getVelocity();
        }
        else if (msg.isNoteOff())
        {
            noteQueue.removeFirstMatchingValue (msg.getNoteNumber());
        }
    }
    
    const int curNote = noteQueue.size() > 0 ? noteQueue.getFirst() : -1;
    
    if (curNote != lastNote)
    {
        int v = curNote == -1 ? 0 : velocity;
        apu.write_register (0x4000, 0xF0 | int (v / 127.0 * 0xF));
        
        if (curNote != -1)
        {
            int period = 111860.8 / MidiMessage::getMidiNoteInHertz (curNote) - 1;
            
            apu.write_register (0x4002, period & 0xFF);
            apu.write_register (0x4003, (period >> 8) & 0x7);
        }
        lastNote = curNote;
    }
    
    int todo = buffer.getNumSamples();
    int done = 0;
    while (todo > 0)
    {
        if (apu.samples_avail() == 0)
            apu.end_frame();
        
        Simple_Apu::sample_t out[1024];
        int count = apu.read_samples(out, jmin (todo, int (apu.samples_avail()), 1024));
        
        float* data = buffer.getWritePointer (0, done);
        for (int i = 0; i < count; i++)
            data[i] = out[i] / 32768.0f;
        
        done += count;
        todo -= count;
    }
    
    outputLevel.trackBuffer (buffer);
}

//==============================================================================
bool RP2A03AudioProcessor::hasEditor() const
{
    return true;
}

AudioProcessorEditor* RP2A03AudioProcessor::createEditor()
{
    return new RP2A03AudioProcessorEditor (*this);
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new RP2A03AudioProcessor();
}
