/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"

using namespace gin;

const char* RP2A03AudioProcessor::paramPulse1Level      = "pulse1Level";
const char* RP2A03AudioProcessor::paramPulse1DutyCycle  = "pulse1Duty";
const char* RP2A03AudioProcessor::paramPulse2Level      = "pulse2Level";
const char* RP2A03AudioProcessor::paramPulse2DutyCycle  = "pulse2Duty";
const char* RP2A03AudioProcessor::paramTriangleLevel    = "triangleLevel";
const char* RP2A03AudioProcessor::paramNoiseLevel       = "noiseLevel";
const char* RP2A03AudioProcessor::paramNoiseShort       = "noisePeriod";
const char* RP2A03AudioProcessor::paramOutput           = "output";
const char* RP2A03AudioProcessor::paramPulse1Tune       = "pulse1Tune";
const char* RP2A03AudioProcessor::paramPulse1TuneFine   = "pulse1TuneFine";
const char* RP2A03AudioProcessor::paramPulse2Tune       = "pulse2Tune";
const char* RP2A03AudioProcessor::paramPulse2TuneFine   = "pulse2TuneFine";
const char* RP2A03AudioProcessor::paramTriangleTune     = "triangleTune";
const char* RP2A03AudioProcessor::paramTriangleTuneFine = "triangleTuneFine";
const char* RP2A03AudioProcessor::paramPulse1Sweep      = "pulse1Sweep";
const char* RP2A03AudioProcessor::paramPulse1Shift      = "pulse1Shift";
const char* RP2A03AudioProcessor::paramPulse2Sweep      = "pulse2Sweep";
const char* RP2A03AudioProcessor::paramPulse2Shift      = "pulse2Shift";

//==============================================================================
String percentTextFunction (const Parameter& p, float v)
{
    return String::formatted("%.0f%%", v / p.getUserRangeEnd() * 100);
}

String onOffTextFunction (const Parameter&, float v)
{
    return v > 0.0f ? "On" : "Off";
}

String dutyTextFunction (const Parameter&, float v)
{
    const int duty = int (v);
    switch (duty)
    {
        case 0: return "12.5%";
        case 1: return "25%";
        case 2: return "50%";
        case 3: return "75%";
    }
    return "";
}

String sweepTextFunction (const Parameter&, float v)
{
    String str;
    switch (int (v))
    {
        case 0: str = "Off"; break;
        default: str = String (int (v));
    }
    return str;
}

String intTextFunction (const Parameter&, float v)
{
    return String (int (v));
}

//==============================================================================
RP2A03AudioProcessor::RP2A03AudioProcessor()
{
    addPluginParameter (new Parameter (paramPulse1Level,     "Pulse 1 Level",      "Pulse",       "", 0.0f, 1.0f,  0.0f, 1.0f, 1.0f, percentTextFunction));
    addPluginParameter (new Parameter (paramPulse1DutyCycle, "Pulse 1 Duty Cycle", "Duty Cycle",  "", 0.0f, 3.0f,  1.0f, 0.0f, 1.0f, dutyTextFunction));
    addPluginParameter (new Parameter (paramPulse2Level,     "Pulse 2 Level",      "Pulse",       "", 0.0f, 1.0f,  0.0f, 0.0f, 1.0f, percentTextFunction));
    addPluginParameter (new Parameter (paramPulse2DutyCycle, "Pulse 2 Duty Cycle", "Duty Cycle",  "", 0.0f, 3.0f,  1.0f, 0.0f, 1.0f, dutyTextFunction));
    addPluginParameter (new Parameter (paramNoiseLevel,      "Noise Level",        "Noise",       "", 0.0f, 1.0f,  0.0f, 0.0f, 1.0f, percentTextFunction));
    addPluginParameter (new Parameter (paramNoiseShort,      "Noise Short",        "Short",       "", 0.0f, 1.0f,  1.0f, 0.0f, 1.0f, onOffTextFunction));
    addPluginParameter (new Parameter (paramTriangleLevel,   "Triangle Level",     "Triangle",    "", 0.0f, 1.0f,  1.0f, 0.0f, 1.0f, onOffTextFunction));
    addPluginParameter (new Parameter (paramOutput,          "Output",             "Output",      "", 0.0f, 1.0f,  0.0f, 1.0f, 1.0f, percentTextFunction));
    addPluginParameter (new Parameter (paramPulse1Tune,      "Pulse 1 Tune",       "Tune",        "", -48.0f, 48.0f, 1.0f, 0.0f, 1.0f, intTextFunction));
    addPluginParameter (new Parameter (paramPulse1TuneFine,  "Pulse 1 Tune Fine",  "Fine",        "", -100.0f, 100.0f, 1.0f, 0.0f, 1.0f, intTextFunction));
    addPluginParameter (new Parameter (paramPulse2Tune,      "Pulse 2 Tune",       "Tune",        "", -48.0f, 48.0f, 1.0f, 0.0f, 1.0f, intTextFunction));
    addPluginParameter (new Parameter (paramPulse2TuneFine,  "Pulse 2 Tune Fine",  "Fine",        "", -100.0f, 100.0f, 1.0f, 0.0f, 1.0f, intTextFunction));
    addPluginParameter (new Parameter (paramTriangleTune,    "Triangle Tune",      "Tune",        "", -48.0f, 48.0f, 1.0f, 0.0f, 1.0f, intTextFunction));
    addPluginParameter (new Parameter (paramTriangleTuneFine,"Triangle Tune Fine", "Fine",        "", -100.0f, 100.0f, 1.0f, 0.0f, 1.0f, intTextFunction));
    addPluginParameter (new Parameter (paramPulse1Sweep,     "Pulse 1 Sweep",      "Sweep",       "", -8.0f, 8.0f, 1.0f, 0.0f, 1.0f, sweepTextFunction));
    addPluginParameter (new Parameter (paramPulse1Shift,     "Pulse 1 Shift",      "Shift",       "", 0.0f, 7.0f, 1.0f, 0.0f, 1.0f, intTextFunction));
    addPluginParameter (new Parameter (paramPulse2Sweep,     "Pulse 2 Sweep",      "Sweep",       "", -8.0f, 8.0f, 1.0f, 0.0f, 1.0f, sweepTextFunction));
    addPluginParameter (new Parameter (paramPulse2Shift,     "Pulse 2 Shift",      "Shift",       "", 0.0f, 7.0f, 1.0f, 0.0f, 1.0f, intTextFunction));
}

RP2A03AudioProcessor::~RP2A03AudioProcessor()
{
}

//==============================================================================
void RP2A03AudioProcessor::prepareToPlay (double sampleRate, int)
{
    apu.sample_rate (long (sampleRate));
    apu.write_register (0x4015, 0x0F);
    
    outputSmoothed.reset (sampleRate, 0.05);
}

void RP2A03AudioProcessor::releaseResources()
{
}

void RP2A03AudioProcessor::runUntil (int& done, AudioSampleBuffer& buffer, int pos)
{
    int todo = jmin (pos, buffer.getNumSamples()) - done;
    
    while (todo > 0)
    {
        if (apu.samples_avail() == 0)
            apu.step();
        
        Simple_Apu::sample_t out[1024];
        int count = int (apu.read_samples(out, jmin (todo, int (apu.samples_avail()), 1024)));
        
        float* data = buffer.getWritePointer (0, done);
        for (int i = 0; i < count; i++)
            data[i] = out[i] / 32768.0f;
        
        done += count;
        todo -= count;
    }

}

void RP2A03AudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midi)
{
    const float p1Level = parameterValue (paramPulse1Level);
    const int p1Duty    = parameterIntValue (paramPulse1DutyCycle);
    const int p1Tune    = parameterIntValue (paramPulse1Tune);
    const int p1Fine    = parameterIntValue (paramPulse1TuneFine);
    const float p2Level = parameterValue (paramPulse2Level);
    const int p2Duty    = parameterIntValue (paramPulse2DutyCycle);
    const int p2Tune    = parameterIntValue (paramPulse2Tune);
    const int p2Fine    = parameterIntValue (paramPulse2TuneFine);
    const float tLevel  = parameterValue (paramTriangleLevel);
    const int tTune     = parameterIntValue (paramTriangleTune);
    const int tFine     = parameterIntValue (paramTriangleTuneFine);
    const float nLevel  = parameterValue (paramNoiseLevel);
    const bool nShort   = parameterValue (paramNoiseShort) > 0.0f;
    const int p1Sweep   = parameterIntValue (paramPulse1Sweep);
    const int p1Shift   = parameterIntValue (paramPulse1Shift);
    const int p2Sweep   = parameterIntValue (paramPulse2Sweep);
    const int p2Shift   = parameterIntValue (paramPulse2Shift);
    
    outputSmoothed.setValue (getParameter (paramOutput)->getUserValue());

    int done = 0;
    runUntil (done, buffer, 0);
    
    int pos = 0;
    MidiMessage msg;
    MidiBuffer::Iterator itr (midi);
    while (itr.getNextEvent (msg, pos))
    {
        runUntil (done, buffer, pos);
        
        if (msg.isNoteOn())
        {
            noteQueue.add (msg.getNoteNumber());
            velocity = msg.getVelocity();
        }
        else if (msg.isNoteOff())
        {
            noteQueue.removeFirstMatchingValue (msg.getNoteNumber());
        }
        else if (msg.isAllNotesOff())
        {
            noteQueue.clear();
        }
        
        const int curNote = noteQueue.size() > 0 ? noteQueue.getLast() : -1;
        
        if (curNote != lastNote)
        {
            int v = curNote == -1 ? 0 : velocity;
            
            // Pulse 1
            apu.write_register (0x4000, (p1Duty << 6) | 0x30 | int (p1Level * v / 127.0 * 0xF));
            
            if (curNote != -1)
            {
                int period = int (111860.8 / getMidiNoteInHertz (curNote + p1Tune + p1Fine / 100.0) - 1);
                
                if (p1Sweep != 0)
                    apu.write_register (0x4001, (p1Sweep != 0 ? 0x80 : 0x00) |
                                                ((abs (p1Sweep) - 1) << 4) |
                                                (((p1Sweep < 0) ? 0 : 1) << 3) |
                                                p1Shift);
                else
                    apu.write_register (0x4005, 0x00);

                apu.write_register (0x4002, period & 0xFF);
                apu.write_register (0x4003, (period >> 8) & 0x7);
            }
            
            // Pulse 2
            apu.write_register (0x4004, (p2Duty << 6) | 0x30 | int (p2Level * v / 127.0 * 0xF));
            
            if (curNote != -1)
            {
                int period = int (111860.8 / getMidiNoteInHertz (curNote + p2Tune + p2Fine / 100.0) - 1);
                
                if (p2Sweep != 0)
                    apu.write_register (0x4005, (p2Sweep != 0 ? 0x80 : 0x00) |
                                                ((abs (p2Sweep) - 1) << 4) |
                                                (((p2Sweep < 0) ? 0 : 1) << 3) |
                                                p2Shift);
                else
                    apu.write_register (0x4005, 0x00);
                    
                apu.write_register (0x4006, period & 0xFF);
                apu.write_register (0x4007, (period >> 8) & 0x7);
            }
            
            // Triangle
            apu.write_register (0x4008, curNote == -1 ? 0x00 : 0xFF);
            if (curNote != -1)
            {
                int period = int (tLevel == 1.0f ? 111860.8 / getMidiNoteInHertz (curNote + tTune + tFine / 100.0) * 2 - 1 : 0);
                
                apu.write_register (0x400A, period & 0xFF);
                apu.write_register (0x400B, (period >> 8) & 0x7);
            }
            
            // Noise
            apu.write_register (0x400C, 0x30 | int (nLevel * v / 127.0 * 0xF));
            
            if (curNote != -1)
            {
                apu.write_register (0x400E, (nShort ? 0x80 : 0x00) | (curNote % 16));
                apu.write_register (0x400F, 0xFF);
            }
            
            lastNote = curNote;
        }
    }
    
    runUntil (done, buffer, buffer.getNumSamples());
    
    float* data = buffer.getWritePointer (0);
    for (int i = 0; i < buffer.getNumSamples(); i++)
        data[i] *= outputSmoothed.getNextValue();
    
    ScopedLock sl (editorLock);
     if (editor)
         editor->scope.addSamples (data, buffer.getNumSamples());
}

//==============================================================================
bool RP2A03AudioProcessor::hasEditor() const
{
    return true;
}

AudioProcessorEditor* RP2A03AudioProcessor::createEditor()
{
    editor = new RP2A03AudioProcessorEditor (*this);
    return editor;
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new RP2A03AudioProcessor();
}
